/* tslint:disable */
/* eslint-disable */
/**
 * VMClarity APIs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnnotationsInner
 */
export interface AnnotationsInner {
    /**
     * 
     * @type {string}
     * @memberof AnnotationsInner
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationsInner
     */
    'value'?: string;
}
/**
 * An object that is returned in all cases of failures.
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'message'?: string;
}
/**
 * Describes an asset object.
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Asset
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetType}
     * @memberof Asset
     */
    'assetInfo'?: AssetType;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'firstSeen'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'terminatedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'lastSeen'?: string;
    /**
     * Total number of scans that have ever run for this asset
     * @type {number}
     * @memberof Asset
     */
    'scansCount'?: number;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof Asset
     */
    'summary'?: ScanFindingsSummary;
    /**
     * List of providers which discover the asset.
     * @type {Array<ProviderRelationship>}
     * @memberof Asset
     */
    'providers'?: Array<ProviderRelationship>;
}
/**
 * 
 * @export
 * @interface AssetExists
 */
export interface AssetExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof AssetExists
     */
    'message'?: string;
    /**
     * 
     * @type {Asset}
     * @memberof AssetExists
     */
    'asset'?: Asset;
}
/**
 * Describes a relationship to an asset which can be expanded.
 * @export
 * @interface AssetRelationship
 */
export interface AssetRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof AssetRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetType}
     * @memberof AssetRelationship
     */
    'assetInfo'?: AssetType;
    /**
     * Total number of scans that have ever run for this asset
     * @type {number}
     * @memberof AssetRelationship
     */
    'scansCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'firstSeen'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'terminatedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'lastSeen'?: string;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof AssetRelationship
     */
    'summary'?: ScanFindingsSummary;
    /**
     * List of providers which discover the asset.
     * @type {Array<ProviderRelationship>}
     * @memberof AssetRelationship
     */
    'providers'?: Array<ProviderRelationship>;
}
/**
 * 
 * @export
 * @interface AssetScan
 */
export interface AssetScan {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetScan
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScan
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScan
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
    /**
     * 
     * @type {string}
     * @memberof AssetScan
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetScan
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof AssetScan
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {ScanRelationship}
     * @memberof AssetScan
     */
    'scan'?: ScanRelationship;
    /**
     * 
     * @type {AssetScanStatus}
     * @memberof AssetScan
     */
    'status'?: AssetScanStatus;
    /**
     * 
     * @type {SbomScan}
     * @memberof AssetScan
     */
    'sboms'?: SbomScan;
    /**
     * 
     * @type {VulnerabilityScan}
     * @memberof AssetScan
     */
    'vulnerabilities'?: VulnerabilityScan;
    /**
     * 
     * @type {MalwareScan}
     * @memberof AssetScan
     */
    'malware'?: MalwareScan;
    /**
     * 
     * @type {RootkitScan}
     * @memberof AssetScan
     */
    'rootkits'?: RootkitScan;
    /**
     * 
     * @type {SecretScan}
     * @memberof AssetScan
     */
    'secrets'?: SecretScan;
    /**
     * 
     * @type {MisconfigurationScan}
     * @memberof AssetScan
     */
    'misconfigurations'?: MisconfigurationScan;
    /**
     * 
     * @type {ExploitScan}
     * @memberof AssetScan
     */
    'exploits'?: ExploitScan;
    /**
     * 
     * @type {InfoFinderScan}
     * @memberof AssetScan
     */
    'infoFinder'?: InfoFinderScan;
    /**
     * 
     * @type {boolean}
     * @memberof AssetScan
     */
    'findingsProcessed'?: boolean;
    /**
     * 
     * @type {ResourceCleanupStatus}
     * @memberof AssetScan
     */
    'resourceCleanupStatus'?: ResourceCleanupStatus;
    /**
     * 
     * @type {AssetScanStats}
     * @memberof AssetScan
     */
    'stats'?: AssetScanStats;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof AssetScan
     */
    'summary'?: ScanFindingsSummary;
    /**
     * 
     * @type {ProviderRelationship}
     * @memberof AssetScan
     */
    'provider'?: ProviderRelationship;
}
/**
 * 
 * @export
 * @interface AssetScanEstimation
 */
export interface AssetScanEstimation {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetScanEstimation
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'id'?: string;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof AssetScanEstimation
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {ScanEstimationRelationship}
     * @memberof AssetScanEstimation
     */
    'scanEstimation'?: ScanEstimationRelationship;
    /**
     * 
     * @type {AssetScanEstimationState}
     * @memberof AssetScanEstimation
     */
    'state'?: AssetScanEstimationState;
    /**
     * 
     * @type {Estimation}
     * @memberof AssetScanEstimation
     */
    'estimation'?: Estimation;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof AssetScanEstimation
     */
    'assetScanTemplate'?: AssetScanTemplate;
    /**
     * 
     * @type {number}
     * @memberof AssetScanEstimation
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'endTime'?: string;
    /**
     * The duration in seconds this resource should last until it is deleted.
     * @type {number}
     * @memberof AssetScanEstimation
     */
    'ttlSecondsAfterFinished'?: number;
    /**
     * The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'deleteAfter'?: string;
}
/**
 * 
 * @export
 * @interface AssetScanEstimationExists
 */
export interface AssetScanEstimationExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof AssetScanEstimationExists
     */
    'message'?: string;
    /**
     * 
     * @type {AssetScanEstimation}
     * @memberof AssetScanEstimationExists
     */
    'assetScanEstimation'?: AssetScanEstimation;
}
/**
 * 
 * @export
 * @interface AssetScanEstimationRelationship
 */
export interface AssetScanEstimationRelationship {
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimationRelationship
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AssetScanEstimationState
 */
export interface AssetScanEstimationState {
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimationState
     */
    'state'?: AssetScanEstimationStateStateEnum;
    /**
     * Human-readable message indicating details about the last state transition.
     * @type {string}
     * @memberof AssetScanEstimationState
     */
    'stateMessage'?: string;
    /**
     * Machine-readable, UpperCamelCase text indicating the reason for the condition\'s last transition.
     * @type {string}
     * @memberof AssetScanEstimationState
     */
    'stateReason'?: AssetScanEstimationStateStateReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimationState
     */
    'lastTransitionTime'?: string;
}

export const AssetScanEstimationStateStateEnum = {
    Pending: 'Pending',
    Aborted: 'Aborted',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type AssetScanEstimationStateStateEnum = typeof AssetScanEstimationStateStateEnum[keyof typeof AssetScanEstimationStateStateEnum];
export const AssetScanEstimationStateStateReasonEnum = {
    Aborted: 'Aborted',
    TimedOut: 'TimedOut',
    Unexpected: 'Unexpected',
    Success: 'Success'
} as const;

export type AssetScanEstimationStateStateReasonEnum = typeof AssetScanEstimationStateStateReasonEnum[keyof typeof AssetScanEstimationStateStateReasonEnum];

/**
 * 
 * @export
 * @interface AssetScanEstimations
 */
export interface AssetScanEstimations {
    /**
     * Total AssetScanEstimations count according to the given filters
     * @type {number}
     * @memberof AssetScanEstimations
     */
    'count'?: number;
    /**
     * List of AssetScanEstimations according to the given filters
     * @type {Array<AssetScanEstimation>}
     * @memberof AssetScanEstimations
     */
    'items'?: Array<AssetScanEstimation>;
}
/**
 * 
 * @export
 * @interface AssetScanExists
 */
export interface AssetScanExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof AssetScanExists
     */
    'message'?: string;
    /**
     * 
     * @type {AssetScan}
     * @memberof AssetScanExists
     */
    'assetScan'?: AssetScan;
}
/**
 * Global statistics for asset scan of all families.
 * @export
 * @interface AssetScanGeneralStats
 */
export interface AssetScanGeneralStats {
    /**
     * 
     * @type {AssetScanScanTime}
     * @memberof AssetScanGeneralStats
     */
    'scanTime'?: AssetScanScanTime;
}
/**
 * Statistics per asset scan input.
 * @export
 * @interface AssetScanInputScanStats
 */
export interface AssetScanInputScanStats {
    /**
     * The input type (ROOTFS, DIR, IMAGE etc.)
     * @type {string}
     * @memberof AssetScanInputScanStats
     */
    'type'?: string;
    /**
     * The input path (/mnt/snapshot for ex.)
     * @type {string}
     * @memberof AssetScanInputScanStats
     */
    'path'?: string;
    /**
     * The input size in MB.
     * @type {number}
     * @memberof AssetScanInputScanStats
     */
    'size'?: number;
    /**
     * 
     * @type {AssetScanScanTime}
     * @memberof AssetScanInputScanStats
     */
    'scanTime'?: AssetScanScanTime;
}
/**
 * 
 * @export
 * @interface AssetScanRelationship
 */
export interface AssetScanRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetScanRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScanRelationship
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScanRelationship
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
    /**
     * 
     * @type {string}
     * @memberof AssetScanRelationship
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof AssetScanRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof AssetScanRelationship
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {ScanRelationship}
     * @memberof AssetScanRelationship
     */
    'scan'?: ScanRelationship;
    /**
     * 
     * @type {AssetScanStatus}
     * @memberof AssetScanRelationship
     */
    'status'?: AssetScanStatus;
    /**
     * 
     * @type {SbomScan}
     * @memberof AssetScanRelationship
     */
    'sboms'?: SbomScan;
    /**
     * 
     * @type {VulnerabilityScan}
     * @memberof AssetScanRelationship
     */
    'vulnerabilities'?: VulnerabilityScan;
    /**
     * 
     * @type {MalwareScan}
     * @memberof AssetScanRelationship
     */
    'malware'?: MalwareScan;
    /**
     * 
     * @type {RootkitScan}
     * @memberof AssetScanRelationship
     */
    'rootkits'?: RootkitScan;
    /**
     * 
     * @type {SecretScan}
     * @memberof AssetScanRelationship
     */
    'secrets'?: SecretScan;
    /**
     * 
     * @type {MisconfigurationScan}
     * @memberof AssetScanRelationship
     */
    'misconfigurations'?: MisconfigurationScan;
    /**
     * 
     * @type {ExploitScan}
     * @memberof AssetScanRelationship
     */
    'exploits'?: ExploitScan;
    /**
     * 
     * @type {InfoFinderScan}
     * @memberof AssetScanRelationship
     */
    'infoFinder'?: InfoFinderScan;
    /**
     * 
     * @type {boolean}
     * @memberof AssetScanRelationship
     */
    'findingsProcessed'?: boolean;
    /**
     * 
     * @type {ResourceCleanupStatus}
     * @memberof AssetScanRelationship
     */
    'resourceCleanupStatus'?: ResourceCleanupStatus;
    /**
     * 
     * @type {AssetScanStats}
     * @memberof AssetScanRelationship
     */
    'stats'?: AssetScanStats;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof AssetScanRelationship
     */
    'summary'?: ScanFindingsSummary;
}
/**
 * 
 * @export
 * @interface AssetScanScanTime
 */
export interface AssetScanScanTime {
    /**
     * 
     * @type {string}
     * @memberof AssetScanScanTime
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetScanScanTime
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @interface AssetScanState
 */
export interface AssetScanState {
    /**
     * 
     * @type {string}
     * @memberof AssetScanState
     */
    'state'?: AssetScanStateStateEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetScanState
     */
    'lastTransitionTime'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetScanState
     */
    'errors'?: Array<string> | null;
}

export const AssetScanStateStateEnum = {
    NotScanned: 'NotScanned',
    Pending: 'Pending',
    Scheduled: 'Scheduled',
    ReadyToScan: 'ReadyToScan',
    InProgress: 'InProgress',
    Aborted: 'Aborted',
    Done: 'Done'
} as const;

export type AssetScanStateStateEnum = typeof AssetScanStateStateEnum[keyof typeof AssetScanStateStateEnum];

/**
 * 
 * @export
 * @interface AssetScanStats
 */
export interface AssetScanStats {
    /**
     * 
     * @type {AssetScanGeneralStats}
     * @memberof AssetScanStats
     */
    'general'?: AssetScanGeneralStats;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'sbom'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'vulnerabilities'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'malware'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'rootkits'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'secrets'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'misconfigurations'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'exploits'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'infoFinder'?: Array<AssetScanInputScanStats>;
}
/**
 * 
 * @export
 * @interface AssetScanStatus
 */
export interface AssetScanStatus {
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'general'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'sbom'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'vulnerabilities'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'malware'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'rootkits'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'secrets'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'misconfigurations'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'exploits'?: AssetScanState;
    /**
     * 
     * @type {AssetScanState}
     * @memberof AssetScanStatus
     */
    'infoFinder'?: AssetScanState;
}
/**
 * 
 * @export
 * @interface AssetScanTemplate
 */
export interface AssetScanTemplate {
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScanTemplate
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScanTemplate
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
}
/**
 * 
 * @export
 * @interface AssetScanTemplateReadOnly
 */
export interface AssetScanTemplateReadOnly {
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScanTemplateReadOnly
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScanTemplateReadOnly
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
}
/**
 * 
 * @export
 * @interface AssetScans
 */
export interface AssetScans {
    /**
     * Total asset scans count according to the given filters
     * @type {number}
     * @memberof AssetScans
     */
    'count'?: number;
    /**
     * List of asset scans according to the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<AssetScan>}
     * @memberof AssetScans
     */
    'items'?: Array<AssetScan>;
}
/**
 * 
 * @export
 * @interface AssetType
 */
export interface AssetType {
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'instanceID': string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof AssetType
     */
    'instanceProvider'?: CloudProvider;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'location': string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof AssetType
     */
    'tags'?: Array<Tag> | null;
    /**
     * 
     * @type {Array<SecurityGroup>}
     * @memberof AssetType
     */
    'securityGroups'?: Array<SecurityGroup> | null;
    /**
     * 
     * @type {ContainerImageInfo}
     * @memberof AssetType
     */
    'image': ContainerImageInfo;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'instanceType': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'launchTime': string;
    /**
     * 
     * @type {RootVolume}
     * @memberof AssetType
     */
    'rootVolume': RootVolume;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'podName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'dirName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'imageID': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetType
     */
    'repoTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetType
     */
    'repoDigests'?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof AssetType
     */
    'labels'?: Array<Tag> | null;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'architecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'os'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetType
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'containerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'containerID': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'createdAt'?: string;
}


/**
 * 
 * @export
 * @interface Assets
 */
export interface Assets {
    /**
     * Total assets count according the given filters
     * @type {number}
     * @memberof Assets
     */
    'count'?: number;
    /**
     * List of assets in the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<Asset>}
     * @memberof Assets
     */
    'items'?: Array<Asset>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CloudProvider = {
    Aws: 'AWS',
    Azure: 'Azure',
    Gcp: 'GCP',
    Docker: 'Docker',
    External: 'External',
    Kubernetes: 'Kubernetes'
} as const;

export type CloudProvider = typeof CloudProvider[keyof typeof CloudProvider];


/**
 * 
 * @export
 * @interface ContainerImageInfo
 */
export interface ContainerImageInfo {
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'imageID': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerImageInfo
     */
    'repoTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerImageInfo
     */
    'repoDigests'?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ContainerImageInfo
     */
    'labels'?: Array<Tag> | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'architecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'os'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContainerImageInfo
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface ContainerInfo
 */
export interface ContainerInfo {
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'containerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'location'?: string;
    /**
     * 
     * @type {ContainerImageInfo}
     * @memberof ContainerInfo
     */
    'image'?: ContainerImageInfo;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'containerID': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ContainerInfo
     */
    'labels'?: Array<Tag> | null;
}
/**
 * 
 * @export
 * @interface CostBreakdownComponent
 */
export interface CostBreakdownComponent {
    /**
     * 
     * @type {string}
     * @memberof CostBreakdownComponent
     */
    'operation': string;
    /**
     * 
     * @type {number}
     * @memberof CostBreakdownComponent
     */
    'cost': number;
}
/**
 * 
 * @export
 * @interface DirInfo
 */
export interface DirInfo {
    /**
     * 
     * @type {string}
     * @memberof DirInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof DirInfo
     */
    'dirName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DirInfo
     */
    'location'?: string;
}
/**
 * 
 * @export
 * @interface Estimation
 */
export interface Estimation {
    /**
     * The estimated scan duration (seconds)
     * @type {number}
     * @memberof Estimation
     */
    'duration'?: number;
    /**
     * The estimated scan size (GB)
     * @type {number}
     * @memberof Estimation
     */
    'size'?: number;
    /**
     * The estimated scan cost ($)
     * @type {number}
     * @memberof Estimation
     */
    'cost'?: number;
    /**
     * 
     * @type {Array<CostBreakdownComponent>}
     * @memberof Estimation
     */
    'costBreakdown'?: Array<CostBreakdownComponent>;
}
/**
 * 
 * @export
 * @interface Exploit
 */
export interface Exploit {
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'cveID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'sourceDB'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Exploit
     */
    'urls'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ExploitFindingInfo
 */
export interface ExploitFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'cveID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'sourceDB'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExploitFindingInfo
     */
    'urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface ExploitScan
 */
export interface ExploitScan {
    /**
     * 
     * @type {Array<Exploit>}
     * @memberof ExploitScan
     */
    'exploits'?: Array<Exploit> | null;
}
/**
 * 
 * @export
 * @interface ExploitsConfig
 */
export interface ExploitsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof ExploitsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExploitsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Finding
 */
export interface Finding {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Finding
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof Finding
     */
    'id'?: string;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof Finding
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {AssetScanRelationship}
     * @memberof Finding
     */
    'foundBy'?: AssetScanRelationship;
    /**
     * When this finding was discovered by a scan
     * @type {string}
     * @memberof Finding
     */
    'foundOn'?: string;
    /**
     * When this finding was invalidated by a newer scan
     * @type {string}
     * @memberof Finding
     */
    'invalidatedOn'?: string;
    /**
     * 
     * @type {FindingAllOfFindingInfo}
     * @memberof Finding
     */
    'findingInfo'?: FindingAllOfFindingInfo;
}
/**
 * 
 * @export
 * @interface FindingAllOfFindingInfo
 */
export interface FindingAllOfFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'version'?: string;
    /**
     * 
     * @type {InfoType}
     * @memberof FindingAllOfFindingInfo
     */
    'type'?: InfoType;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingAllOfFindingInfo
     */
    'licenses'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingAllOfFindingInfo
     */
    'cpes'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'purl'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'vulnerabilityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'description'?: string;
    /**
     * 
     * @type {MisconfigurationSeverity}
     * @memberof FindingAllOfFindingInfo
     */
    'severity'?: MisconfigurationSeverity;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingAllOfFindingInfo
     */
    'links'?: Array<string> | null;
    /**
     * 
     * @type {VulnerabilityDistro}
     * @memberof FindingAllOfFindingInfo
     */
    'distro'?: VulnerabilityDistro;
    /**
     * 
     * @type {Array<VulnerabilityCvss>}
     * @memberof FindingAllOfFindingInfo
     */
    'cvss'?: Array<VulnerabilityCvss> | null;
    /**
     * 
     * @type {Package}
     * @memberof FindingAllOfFindingInfo
     */
    'package'?: Package;
    /**
     * 
     * @type {VulnerabilityFix}
     * @memberof FindingAllOfFindingInfo
     */
    'fix'?: VulnerabilityFix;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'layerId'?: string;
    /**
     * File path containing the info
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'malwareName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'malwareType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'ruleName'?: string;
    /**
     * Name of the file containing the secret
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'filePath'?: string;
    /**
     * 
     * @type {number}
     * @memberof FindingAllOfFindingInfo
     */
    'startLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindingAllOfFindingInfo
     */
    'endLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindingAllOfFindingInfo
     */
    'startColumn'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindingAllOfFindingInfo
     */
    'endColumn'?: number;
    /**
     * Note: this is not unique
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'scannerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'scannedPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'testCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'testID'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'testDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'remediation'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'rootkitName'?: string;
    /**
     * 
     * @type {RootkitType}
     * @memberof FindingAllOfFindingInfo
     */
    'rootkitType'?: RootkitType;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'cveID'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'sourceDB'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingAllOfFindingInfo
     */
    'urls'?: Array<string> | null;
    /**
     * The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
     * @type {string}
     * @memberof FindingAllOfFindingInfo
     */
    'data'?: string;
}


/**
 * 
 * @export
 * @interface FindingExists
 */
export interface FindingExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof FindingExists
     */
    'message'?: string;
    /**
     * 
     * @type {Finding}
     * @memberof FindingExists
     */
    'finding'?: Finding;
}
/**
 * 
 * @export
 * @interface Findings
 */
export interface Findings {
    /**
     * Total findings count according to the given filters
     * @type {number}
     * @memberof Findings
     */
    'count'?: number;
    /**
     * List of findings according to the given filters
     * @type {Array<Finding>}
     * @memberof Findings
     */
    'items'?: Array<Finding>;
}
/**
 * 
 * @export
 * @interface InfoFinderConfig
 */
export interface InfoFinderConfig {
    /**
     * 
     * @type {boolean}
     * @memberof InfoFinderConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof InfoFinderConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InfoFinderFindingInfo
 */
export interface InfoFinderFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'scannerName'?: string;
    /**
     * 
     * @type {InfoType}
     * @memberof InfoFinderFindingInfo
     */
    'type'?: InfoType;
    /**
     * File path containing the info
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'path'?: string;
    /**
     * The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface InfoFinderInfo
 */
export interface InfoFinderInfo {
    /**
     * 
     * @type {string}
     * @memberof InfoFinderInfo
     */
    'scannerName'?: string;
    /**
     * 
     * @type {InfoType}
     * @memberof InfoFinderInfo
     */
    'type'?: InfoType;
    /**
     * File path containing the info
     * @type {string}
     * @memberof InfoFinderInfo
     */
    'path'?: string;
    /**
     * The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
     * @type {string}
     * @memberof InfoFinderInfo
     */
    'data'?: string;
}


/**
 * 
 * @export
 * @interface InfoFinderScan
 */
export interface InfoFinderScan {
    /**
     * 
     * @type {Array<string>}
     * @memberof InfoFinderScan
     */
    'scanners'?: Array<string> | null;
    /**
     * 
     * @type {Array<InfoFinderInfo>}
     * @memberof InfoFinderScan
     */
    'infos'?: Array<InfoFinderInfo> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InfoType = {
    SshKnownHostFingerprint: 'SSHKnownHostFingerprint',
    SshAuthorizedKeyFingerprint: 'SSHAuthorizedKeyFingerprint',
    SshPrivateKeyFingerprint: 'SSHPrivateKeyFingerprint',
    SshDaemonKeyFingerprint: 'SSHDaemonKeyFingerprint',
    Unknown: 'UNKNOWN'
} as const;

export type InfoType = typeof InfoType[keyof typeof InfoType];


/**
 * 
 * @export
 * @interface Malware
 */
export interface Malware {
    /**
     * 
     * @type {string}
     * @memberof Malware
     */
    'malwareName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Malware
     */
    'malwareType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Malware
     */
    'ruleName'?: string;
    /**
     * Path of the file that contains malware
     * @type {string}
     * @memberof Malware
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface MalwareConfig
 */
export interface MalwareConfig {
    /**
     * 
     * @type {boolean}
     * @memberof MalwareConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MalwareConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MalwareFindingInfo
 */
export interface MalwareFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'malwareName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'malwareType'?: string;
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'ruleName'?: string;
    /**
     * Path of the file that contains malware
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface MalwareScan
 */
export interface MalwareScan {
    /**
     * 
     * @type {Array<Malware>}
     * @memberof MalwareScan
     */
    'malware'?: Array<Malware> | null;
    /**
     * 
     * @type {Array<ScannerMetadata>}
     * @memberof MalwareScan
     */
    'metadata'?: Array<ScannerMetadata> | null;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Metadata
     */
    'annotations'?: Array<AnnotationsInner>;
}
/**
 * 
 * @export
 * @interface MetadataReadOnly
 */
export interface MetadataReadOnly {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof MetadataReadOnly
     */
    'annotations'?: Array<AnnotationsInner>;
}
/**
 * 
 * @export
 * @interface Misconfiguration
 */
export interface Misconfiguration {
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'scannerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'scannedPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'testCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'testID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'testDescription'?: string;
    /**
     * 
     * @type {MisconfigurationSeverity}
     * @memberof Misconfiguration
     */
    'severity'?: MisconfigurationSeverity;
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'remediation'?: string;
}


/**
 * 
 * @export
 * @interface MisconfigurationFindingInfo
 */
export interface MisconfigurationFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'scannerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'scannedPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'testCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'testID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'testDescription'?: string;
    /**
     * 
     * @type {MisconfigurationSeverity}
     * @memberof MisconfigurationFindingInfo
     */
    'severity'?: MisconfigurationSeverity;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'remediation'?: string;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface MisconfigurationScan
 */
export interface MisconfigurationScan {
    /**
     * 
     * @type {Array<string>}
     * @memberof MisconfigurationScan
     */
    'scanners'?: Array<string> | null;
    /**
     * 
     * @type {Array<Misconfiguration>}
     * @memberof MisconfigurationScan
     */
    'misconfigurations'?: Array<Misconfiguration> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MisconfigurationSeverity = {
    MisconfigurationHighSeverity: 'MisconfigurationHighSeverity',
    MisconfigurationMediumSeverity: 'MisconfigurationMediumSeverity',
    MisconfigurationLowSeverity: 'MisconfigurationLowSeverity'
} as const;

export type MisconfigurationSeverity = typeof MisconfigurationSeverity[keyof typeof MisconfigurationSeverity];


/**
 * 
 * @export
 * @interface MisconfigurationsConfig
 */
export interface MisconfigurationsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof MisconfigurationsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MisconfigurationsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Package
     */
    'licenses'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Package
     */
    'cpes'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'purl'?: string;
}
/**
 * 
 * @export
 * @interface PackageFindingInfo
 */
export interface PackageFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PackageFindingInfo
     */
    'licenses'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PackageFindingInfo
     */
    'cpes'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'purl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface PodInfo
 */
export interface PodInfo {
    /**
     * 
     * @type {string}
     * @memberof PodInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof PodInfo
     */
    'podName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodInfo
     */
    'location'?: string;
}
/**
 * Describes a provider object.
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Provider
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Provider
     */
    'revision'?: number;
    /**
     * Human-readable name for the provider.
     * @type {string}
     * @memberof Provider
     */
    'displayName'?: string;
    /**
     * Timestamp of the last heartbeat from the provider.
     * @type {string}
     * @memberof Provider
     */
    'lastHeartbeatTime'?: string;
    /**
     * 
     * @type {ProviderStatus}
     * @memberof Provider
     */
    'status'?: ProviderStatus;
    /**
     * Version of the provider runtime that the provider was compiled with.
     * @type {string}
     * @memberof Provider
     */
    'providerRuntimeVersion'?: string;
}
/**
 * 
 * @export
 * @interface ProviderExists
 */
export interface ProviderExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof ProviderExists
     */
    'message'?: string;
    /**
     * 
     * @type {Provider}
     * @memberof ProviderExists
     */
    'provider'?: Provider;
}
/**
 * Describes a relationship to a provider which can be expanded.
 * @export
 * @interface ProviderRelationship
 */
export interface ProviderRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ProviderRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ProviderRelationship
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProviderRelationship
     */
    'revision'?: number;
    /**
     * Human-readable name for the provider.
     * @type {string}
     * @memberof ProviderRelationship
     */
    'displayName'?: string;
    /**
     * Timestamp of the last heartbeat from the provider.
     * @type {string}
     * @memberof ProviderRelationship
     */
    'lastHeartbeatTime'?: string;
    /**
     * 
     * @type {ProviderStatus}
     * @memberof ProviderRelationship
     */
    'status'?: ProviderStatus;
    /**
     * Version of the provider runtime that the provider was compiled with.
     * @type {string}
     * @memberof ProviderRelationship
     */
    'providerRuntimeVersion'?: string;
}
/**
 * 
 * @export
 * @interface ProviderStatus
 */
export interface ProviderStatus {
    /**
     * Describes the health state of the provider.  | State     | Description                                    | | --------- | ---------------------------------------------- | | Healthy   | Provider is healthy.                           | | Unhealthy | Heartbeat received, but Provider is unhealthy. | | Unknown   | No heartbeat received from Provider.           | 
     * @type {string}
     * @memberof ProviderStatus
     */
    'state': ProviderStatusStateEnum;
    /**
     * Machine-readable, UpperCamelCase text indicating the reason for the condition\'s last transition.
     * @type {string}
     * @memberof ProviderStatus
     */
    'reason': ProviderStatusReasonEnum;
    /**
     * Human-readable message indicating details about the last state transition.
     * @type {string}
     * @memberof ProviderStatus
     */
    'message'?: string;
    /**
     * Last date-time when the status has changed.
     * @type {string}
     * @memberof ProviderStatus
     */
    'lastTransitionTime': string;
}

export const ProviderStatusStateEnum = {
    Healthy: 'Healthy',
    Unhealthy: 'Unhealthy',
    Unknown: 'Unknown'
} as const;

export type ProviderStatusStateEnum = typeof ProviderStatusStateEnum[keyof typeof ProviderStatusStateEnum];
export const ProviderStatusReasonEnum = {
    HeartbeatReceived: 'HeartbeatReceived',
    NoHeartbeatReceived: 'NoHeartbeatReceived'
} as const;

export type ProviderStatusReasonEnum = typeof ProviderStatusReasonEnum[keyof typeof ProviderStatusReasonEnum];

/**
 * 
 * @export
 * @interface Providers
 */
export interface Providers {
    /**
     * Total providers count according the given filters
     * @type {number}
     * @memberof Providers
     */
    'count'?: number;
    /**
     * List of providers in the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<Provider>}
     * @memberof Providers
     */
    'items'?: Array<Provider>;
}
/**
 * 
 * @export
 * @interface ResourceCleanupStatus
 */
export interface ResourceCleanupStatus {
    /**
     * Describes the state of resource cleanup.  | State   | Description                                                | | ------- | ---------------------------------------------------------- | | Pending | Initial state for cleaning up resources                    | | Skipped | Resource cleanup has been skipped due to Delete Job Policy | | Failed  | Cleaning up resources has been failed                      | | Done    | Resources have been successfully cleaned up                | 
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'state': ResourceCleanupStatusStateEnum;
    /**
     * Machine readable reason for state transition.  | State   | Reason          | Description                                                            | | ------- | --------------- | ---------------------------------------------------------------------- | | Pending | AssetScanCreate | AssetScan created                                                      | | Skipped | NotApplicable   | Resource cleanup is not required as it is managed outside of VMClarity | | Skipped | DeletePolicy    | Resource cleanup has been skipped due to Delete Job Policy             | | Failed  | ProviderError   | Failed due to Provider error                                           | | Failed  | InternalError   | Failed due to internal error                                           | | Done    | Success         | Successfully completed                                                 | 
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'reason': ResourceCleanupStatusReasonEnum;
    /**
     * Human readable message.
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'message'?: string;
    /**
     * Last date time when the status has changed.
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'lastTransitionTime': string;
}

export const ResourceCleanupStatusStateEnum = {
    Pending: 'Pending',
    Skipped: 'Skipped',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type ResourceCleanupStatusStateEnum = typeof ResourceCleanupStatusStateEnum[keyof typeof ResourceCleanupStatusStateEnum];
export const ResourceCleanupStatusReasonEnum = {
    AssetScanCreated: 'AssetScanCreated',
    NotApplicable: 'NotApplicable',
    DeletePolicy: 'DeletePolicy',
    ProviderError: 'ProviderError',
    InternalError: 'InternalError',
    Success: 'Success'
} as const;

export type ResourceCleanupStatusReasonEnum = typeof ResourceCleanupStatusReasonEnum[keyof typeof ResourceCleanupStatusReasonEnum];

/**
 * Information about VM root volume
 * @export
 * @interface RootVolume
 */
export interface RootVolume {
    /**
     * 
     * @type {number}
     * @memberof RootVolume
     */
    'sizeGB': number;
    /**
     * 
     * @type {string}
     * @memberof RootVolume
     */
    'encrypted': RootVolumeEncryptedEnum;
}

export const RootVolumeEncryptedEnum = {
    True: 'true',
    False: 'false',
    Unknown: 'Unknown'
} as const;

export type RootVolumeEncryptedEnum = typeof RootVolumeEncryptedEnum[keyof typeof RootVolumeEncryptedEnum];

/**
 * 
 * @export
 * @interface Rootkit
 */
export interface Rootkit {
    /**
     * 
     * @type {string}
     * @memberof Rootkit
     */
    'rootkitName'?: string;
    /**
     * 
     * @type {RootkitType}
     * @memberof Rootkit
     */
    'rootkitType'?: RootkitType;
    /**
     * 
     * @type {string}
     * @memberof Rootkit
     */
    'message'?: string;
}


/**
 * 
 * @export
 * @interface RootkitFindingInfo
 */
export interface RootkitFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof RootkitFindingInfo
     */
    'rootkitName'?: string;
    /**
     * 
     * @type {RootkitType}
     * @memberof RootkitFindingInfo
     */
    'rootkitType'?: RootkitType;
    /**
     * 
     * @type {string}
     * @memberof RootkitFindingInfo
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof RootkitFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface RootkitScan
 */
export interface RootkitScan {
    /**
     * 
     * @type {Array<Rootkit>}
     * @memberof RootkitScan
     */
    'rootkits'?: Array<Rootkit> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RootkitType = {
    Memory: 'MEMORY',
    Kernel: 'KERNEL',
    Application: 'APPLICATION',
    Firmware: 'FIRMWARE',
    Unknown: 'UNKNOWN'
} as const;

export type RootkitType = typeof RootkitType[keyof typeof RootkitType];


/**
 * 
 * @export
 * @interface RootkitsConfig
 */
export interface RootkitsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof RootkitsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RootkitsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the \"from time\" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
 * @export
 * @interface RuntimeScheduleScanConfig
 */
export interface RuntimeScheduleScanConfig {
    /**
     * Cron schedule expressions.
     * @type {string}
     * @memberof RuntimeScheduleScanConfig
     */
    'cronLine'?: string;
    /**
     * The next time this ScanConfig should trigger a scan.
     * @type {string}
     * @memberof RuntimeScheduleScanConfig
     */
    'operationTime'?: string;
}
/**
 * 
 * @export
 * @interface SBOMConfig
 */
export interface SBOMConfig {
    /**
     * 
     * @type {boolean}
     * @memberof SBOMConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SBOMConfig
     */
    'analyzers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SbomScan
 */
export interface SbomScan {
    /**
     * 
     * @type {Array<Package>}
     * @memberof SbomScan
     */
    'packages'?: Array<Package> | null;
}
/**
 * Describes a multi-asset scheduled scan.
 * @export
 * @interface Scan
 */
export interface Scan {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Scan
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof Scan
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof Scan
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof Scan
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof Scan
     */
    'assetScanTemplate'?: AssetScanTemplate;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Scan
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'endTime'?: string;
    /**
     * 
     * @type {ScanConfigRelationship}
     * @memberof Scan
     */
    'scanConfig'?: ScanConfigRelationship;
    /**
     * List of asset IDs to be scanned
     * @type {Array<string>}
     * @memberof Scan
     */
    'assetIDs'?: Array<string> | null;
    /**
     * The lifecycle state of this scan.
     * @type {string}
     * @memberof Scan
     */
    'state'?: ScanStateEnum;
    /**
     * Human-readable message indicating details about the last state transition.
     * @type {string}
     * @memberof Scan
     */
    'stateMessage'?: string;
    /**
     * Machine-readable, UpperCamelCase text indicating the reason for the condition\'s last transition.
     * @type {string}
     * @memberof Scan
     */
    'stateReason'?: ScanStateReasonEnum;
    /**
     * 
     * @type {ScanSummary}
     * @memberof Scan
     */
    'summary'?: ScanSummary;
}

export const ScanStateEnum = {
    Pending: 'Pending',
    Discovered: 'Discovered',
    InProgress: 'InProgress',
    Aborted: 'Aborted',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type ScanStateEnum = typeof ScanStateEnum[keyof typeof ScanStateEnum];
export const ScanStateReasonEnum = {
    Aborted: 'Aborted',
    TimedOut: 'TimedOut',
    OneOrMoreAssetFailedToScan: 'OneOrMoreAssetFailedToScan',
    DiscoveryFailed: 'DiscoveryFailed',
    Unexpected: 'Unexpected',
    NothingToScan: 'NothingToScan',
    Success: 'Success'
} as const;

export type ScanStateReasonEnum = typeof ScanStateReasonEnum[keyof typeof ScanStateReasonEnum];

/**
 * Describes a multi-asset scheduled scan config.
 * @export
 * @interface ScanConfig
 */
export interface ScanConfig {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanConfig
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ScanConfig
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScanConfig
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScanConfig
     */
    'name'?: string;
    /**
     * 
     * @type {ScanTemplate}
     * @memberof ScanConfig
     */
    'scanTemplate'?: ScanTemplate;
    /**
     * 
     * @type {RuntimeScheduleScanConfig}
     * @memberof ScanConfig
     */
    'scheduled'?: RuntimeScheduleScanConfig;
    /**
     * if true, the scan config is disabled and no scan should run from it
     * @type {boolean}
     * @memberof ScanConfig
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ScanConfigExists
 */
export interface ScanConfigExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof ScanConfigExists
     */
    'message'?: string;
    /**
     * 
     * @type {ScanConfig}
     * @memberof ScanConfigExists
     */
    'scanConfig'?: ScanConfig;
}
/**
 * Describes a relationship to a scan config which can be expanded.
 * @export
 * @interface ScanConfigRelationship
 */
export interface ScanConfigRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanConfigRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ScanConfigRelationship
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ScanConfigRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScanConfigRelationship
     */
    'name'?: string;
    /**
     * 
     * @type {ScanTemplate}
     * @memberof ScanConfigRelationship
     */
    'scanTemplate'?: ScanTemplate;
    /**
     * 
     * @type {RuntimeScheduleScanConfig}
     * @memberof ScanConfigRelationship
     */
    'scheduled'?: RuntimeScheduleScanConfig;
    /**
     * if true, the scan config is disabled and no scan should run from it
     * @type {boolean}
     * @memberof ScanConfigRelationship
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ScanConfigs
 */
export interface ScanConfigs {
    /**
     * Total scan config count according to the given filters
     * @type {number}
     * @memberof ScanConfigs
     */
    'count'?: number;
    /**
     * List of scan configs according to the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<ScanConfig>}
     * @memberof ScanConfigs
     */
    'items'?: Array<ScanConfig>;
}
/**
 * 
 * @export
 * @interface ScanEstimation
 */
export interface ScanEstimation {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanEstimation
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ScanEstimation
     */
    'id'?: string;
    /**
     * List of asset IDs to be estimated
     * @type {Array<string>}
     * @memberof ScanEstimation
     */
    'assetIDs'?: Array<string>;
    /**
     * 
     * @type {ScanEstimationState}
     * @memberof ScanEstimation
     */
    'state'?: ScanEstimationState;
    /**
     * 
     * @type {string}
     * @memberof ScanEstimation
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScanEstimation
     */
    'endTime'?: string;
    /**
     * AssetScanEstimations which make up this ScanEstimation
     * @type {Array<AssetScanEstimationRelationship>}
     * @memberof ScanEstimation
     */
    'assetScanEstimations'?: Array<AssetScanEstimationRelationship>;
    /**
     * 
     * @type {ScanTemplate}
     * @memberof ScanEstimation
     */
    'scanTemplate'?: ScanTemplate;
    /**
     * 
     * @type {ScanEstimationSummary}
     * @memberof ScanEstimation
     */
    'summary'?: ScanEstimationSummary;
    /**
     * 
     * @type {number}
     * @memberof ScanEstimation
     */
    'revision'?: number;
    /**
     * The duration in seconds this resource should last until it is deleted.
     * @type {number}
     * @memberof ScanEstimation
     */
    'ttlSecondsAfterFinished'?: number;
    /**
     * The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
     * @type {string}
     * @memberof ScanEstimation
     */
    'deleteAfter'?: string;
}
/**
 * 
 * @export
 * @interface ScanEstimationRelationship
 */
export interface ScanEstimationRelationship {
    /**
     * 
     * @type {string}
     * @memberof ScanEstimationRelationship
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ScanEstimationState
 */
export interface ScanEstimationState {
    /**
     * The lifecycle state of this scan estimation.
     * @type {string}
     * @memberof ScanEstimationState
     */
    'state'?: ScanEstimationStateStateEnum;
    /**
     * Human-readable message indicating details about the last state transition.
     * @type {string}
     * @memberof ScanEstimationState
     */
    'stateMessage'?: string;
    /**
     * Machine-readable, UpperCamelCase text indicating the reason for the condition\'s last transition.
     * @type {string}
     * @memberof ScanEstimationState
     */
    'stateReason'?: ScanEstimationStateStateReasonEnum;
}

export const ScanEstimationStateStateEnum = {
    Pending: 'Pending',
    Discovered: 'Discovered',
    InProgress: 'InProgress',
    Aborted: 'Aborted',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type ScanEstimationStateStateEnum = typeof ScanEstimationStateStateEnum[keyof typeof ScanEstimationStateStateEnum];
export const ScanEstimationStateStateReasonEnum = {
    Aborted: 'Aborted',
    TimedOut: 'TimedOut',
    OneOrMoreAssetFailedToEstimate: 'OneOrMoreAssetFailedToEstimate',
    DiscoveryFailed: 'DiscoveryFailed',
    Unexpected: 'Unexpected',
    NothingToEstimate: 'NothingToEstimate',
    Success: 'Success'
} as const;

export type ScanEstimationStateStateReasonEnum = typeof ScanEstimationStateStateReasonEnum[keyof typeof ScanEstimationStateStateReasonEnum];

/**
 * A summary of the AssetScanEstimations under this ScanEstimation
 * @export
 * @interface ScanEstimationSummary
 */
export interface ScanEstimationSummary {
    /**
     * 
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'jobsLeftToRun'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'jobsCompleted'?: number;
    /**
     * Total estimated time the scan will take (seconds)
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'totalScanTime'?: number;
    /**
     * Total estimated size of the scan (GB)
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'totalScanSize'?: number;
    /**
     * Total estimated cost of the scan ($)
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'totalScanCost'?: number;
}
/**
 * 
 * @export
 * @interface ScanEstimations
 */
export interface ScanEstimations {
    /**
     * Total ScanEstimations count according to the given filters
     * @type {number}
     * @memberof ScanEstimations
     */
    'count'?: number;
    /**
     * List of ScanEstimations according to the given filters
     * @type {Array<ScanEstimation>}
     * @memberof ScanEstimations
     */
    'items'?: Array<ScanEstimation>;
}
/**
 * 
 * @export
 * @interface ScanExists
 */
export interface ScanExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof ScanExists
     */
    'message'?: string;
    /**
     * 
     * @type {Scan}
     * @memberof ScanExists
     */
    'scan'?: Scan;
}
/**
 * The configuration of the scanner families within a scan config
 * @export
 * @interface ScanFamiliesConfig
 */
export interface ScanFamiliesConfig {
    /**
     * 
     * @type {SBOMConfig}
     * @memberof ScanFamiliesConfig
     */
    'sbom'?: SBOMConfig;
    /**
     * 
     * @type {VulnerabilitiesConfig}
     * @memberof ScanFamiliesConfig
     */
    'vulnerabilities'?: VulnerabilitiesConfig;
    /**
     * 
     * @type {MalwareConfig}
     * @memberof ScanFamiliesConfig
     */
    'malware'?: MalwareConfig;
    /**
     * 
     * @type {RootkitsConfig}
     * @memberof ScanFamiliesConfig
     */
    'rootkits'?: RootkitsConfig;
    /**
     * 
     * @type {SecretsConfig}
     * @memberof ScanFamiliesConfig
     */
    'secrets'?: SecretsConfig;
    /**
     * 
     * @type {MisconfigurationsConfig}
     * @memberof ScanFamiliesConfig
     */
    'misconfigurations'?: MisconfigurationsConfig;
    /**
     * 
     * @type {ExploitsConfig}
     * @memberof ScanFamiliesConfig
     */
    'exploits'?: ExploitsConfig;
    /**
     * 
     * @type {InfoFinderConfig}
     * @memberof ScanFamiliesConfig
     */
    'infoFinder'?: InfoFinderConfig;
}
/**
 * A summary of the scan findings.
 * @export
 * @interface ScanFindingsSummary
 */
export interface ScanFindingsSummary {
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalPackages'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalExploits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalMalware'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalMisconfigurations'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalRootkits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalSecrets'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalInfoFinder'?: number;
    /**
     * 
     * @type {VulnerabilityScanSummary}
     * @memberof ScanFindingsSummary
     */
    'totalVulnerabilities'?: VulnerabilityScanSummary;
}
/**
 * Describes an expandable relationship to Scan object
 * @export
 * @interface ScanRelationship
 */
export interface ScanRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof ScanRelationship
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof ScanRelationship
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof ScanRelationship
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof ScanRelationship
     */
    'assetScanTemplate'?: AssetScanTemplate;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScanRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'endTime'?: string;
    /**
     * 
     * @type {ScanConfigRelationship}
     * @memberof ScanRelationship
     */
    'scanConfig'?: ScanConfigRelationship;
    /**
     * List of asset IDs to be scanned
     * @type {Array<string>}
     * @memberof ScanRelationship
     */
    'assetIDs'?: Array<string> | null;
    /**
     * The lifecycle state of this scan.
     * @type {string}
     * @memberof ScanRelationship
     */
    'state'?: ScanRelationshipStateEnum;
    /**
     * Human-readable message indicating details about the last state transition.
     * @type {string}
     * @memberof ScanRelationship
     */
    'stateMessage'?: string;
    /**
     * Machine-readable, UpperCamelCase text indicating the reason for the condition\'s last transition.
     * @type {string}
     * @memberof ScanRelationship
     */
    'stateReason'?: ScanRelationshipStateReasonEnum;
    /**
     * 
     * @type {ScanSummary}
     * @memberof ScanRelationship
     */
    'summary'?: ScanSummary;
}

export const ScanRelationshipStateEnum = {
    Pending: 'Pending',
    Discovered: 'Discovered',
    InProgress: 'InProgress',
    Aborted: 'Aborted',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type ScanRelationshipStateEnum = typeof ScanRelationshipStateEnum[keyof typeof ScanRelationshipStateEnum];
export const ScanRelationshipStateReasonEnum = {
    Aborted: 'Aborted',
    TimedOut: 'TimedOut',
    OneOrMoreAssetFailedToScan: 'OneOrMoreAssetFailedToScan',
    DiscoveryFailed: 'DiscoveryFailed',
    Unexpected: 'Unexpected',
    NothingToScan: 'NothingToScan',
    Success: 'Success'
} as const;

export type ScanRelationshipStateReasonEnum = typeof ScanRelationshipStateReasonEnum[keyof typeof ScanRelationshipStateReasonEnum];

/**
 * A summary of the progress of a scan for informational purposes.
 * @export
 * @interface ScanSummary
 */
export interface ScanSummary {
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalPackages'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalExploits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalMalware'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalMisconfigurations'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalRootkits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalSecrets'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalInfoFinder'?: number;
    /**
     * 
     * @type {VulnerabilityScanSummary}
     * @memberof ScanSummary
     */
    'totalVulnerabilities'?: VulnerabilityScanSummary;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'jobsLeftToRun'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'jobsCompleted'?: number;
}
/**
 * 
 * @export
 * @interface ScanTemplate
 */
export interface ScanTemplate {
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof ScanTemplate
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof ScanTemplate
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof ScanTemplate
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof ScanTemplate
     */
    'assetScanTemplate'?: AssetScanTemplate;
}
/**
 * 
 * @export
 * @interface ScanTemplateReadOnly
 */
export interface ScanTemplateReadOnly {
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof ScanTemplateReadOnly
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof ScanTemplateReadOnly
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof ScanTemplateReadOnly
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof ScanTemplateReadOnly
     */
    'assetScanTemplate'?: AssetScanTemplate;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ScanType = {
    Sbom: 'SBOM',
    Vulnerability: 'VULNERABILITY',
    Malware: 'MALWARE',
    Secret: 'SECRET',
    Misconfiguration: 'MISCONFIGURATION',
    Rootkit: 'ROOTKIT',
    Exploit: 'EXPLOIT',
    Infofinder: 'INFOFINDER'
} as const;

export type ScanType = typeof ScanType[keyof typeof ScanType];


/**
 * Configuration of scanner instance
 * @export
 * @interface ScannerInstanceCreationConfig
 */
export interface ScannerInstanceCreationConfig {
    /**
     * 
     * @type {boolean}
     * @memberof ScannerInstanceCreationConfig
     */
    'useSpotInstances': boolean;
    /**
     * 
     * @type {number}
     * @memberof ScannerInstanceCreationConfig
     */
    'retryMaxAttempts'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerInstanceCreationConfig
     */
    'maxPrice'?: string;
}
/**
 * 
 * @export
 * @interface ScannerMetadata
 */
export interface ScannerMetadata {
    /**
     * 
     * @type {string}
     * @memberof ScannerMetadata
     */
    'scannerName'?: string;
    /**
     * 
     * @type {ScannerSummary}
     * @memberof ScannerMetadata
     */
    'scannerSummary'?: ScannerSummary;
}
/**
 * 
 * @export
 * @interface ScannerSummary
 */
export interface ScannerSummary {
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'KnownViruses'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'EngineVersion'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'ScannedDirectories'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'ScannedFiles'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'InfectedFiles'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'SuspectedFiles'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'DataScanned'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'DataRead'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'TimeTaken'?: string;
}
/**
 * 
 * @export
 * @interface Scans
 */
export interface Scans {
    /**
     * Total scans count according to the given filters
     * @type {number}
     * @memberof Scans
     */
    'count'?: number;
    /**
     * List of scans according to the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<Scan>}
     * @memberof Scans
     */
    'items'?: Array<Scan>;
}
/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'description'?: string;
    /**
     * Name of the file containing the secret
     * @type {string}
     * @memberof Secret
     */
    'filePath'?: string;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'startLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'endLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'startColumn'?: number;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'endColumn'?: number;
    /**
     * Note: this is not unique
     * @type {string}
     * @memberof Secret
     */
    'fingerprint'?: string;
}
/**
 * 
 * @export
 * @interface SecretFindingInfo
 */
export interface SecretFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'description'?: string;
    /**
     * Name of the file containing the secret
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'filePath'?: string;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'startLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'endLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'startColumn'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'endColumn'?: number;
    /**
     * Note: this is not unique
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface SecretScan
 */
export interface SecretScan {
    /**
     * 
     * @type {Array<Secret>}
     * @memberof SecretScan
     */
    'secrets'?: Array<Secret> | null;
}
/**
 * 
 * @export
 * @interface SecretsConfig
 */
export interface SecretsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof SecretsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SecretsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * general cloud security group
 * @export
 * @interface SecurityGroup
 */
export interface SecurityGroup {
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    'id': string;
}
/**
 * An object that is returned in cases of success that returns nothing.
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof SuccessResponse
     */
    'message'?: string;
}
/**
 * general cloud tag / label
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface VMInfo
 */
export interface VMInfo {
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'instanceID': string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof VMInfo
     */
    'instanceProvider'?: CloudProvider;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'location': string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof VMInfo
     */
    'tags'?: Array<Tag> | null;
    /**
     * 
     * @type {Array<SecurityGroup>}
     * @memberof VMInfo
     */
    'securityGroups'?: Array<SecurityGroup> | null;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'instanceType': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'launchTime': string;
    /**
     * 
     * @type {RootVolume}
     * @memberof VMInfo
     */
    'rootVolume': RootVolume;
}


/**
 * 
 * @export
 * @interface VulnerabilitiesConfig
 */
export interface VulnerabilitiesConfig {
    /**
     * 
     * @type {boolean}
     * @memberof VulnerabilitiesConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof VulnerabilitiesConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Vulnerability
 */
export interface Vulnerability {
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'vulnerabilityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'description'?: string;
    /**
     * 
     * @type {VulnerabilitySeverity}
     * @memberof Vulnerability
     */
    'severity'?: VulnerabilitySeverity;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vulnerability
     */
    'links'?: Array<string> | null;
    /**
     * 
     * @type {VulnerabilityDistro}
     * @memberof Vulnerability
     */
    'distro'?: VulnerabilityDistro;
    /**
     * 
     * @type {Array<VulnerabilityCvss>}
     * @memberof Vulnerability
     */
    'cvss'?: Array<VulnerabilityCvss> | null;
    /**
     * 
     * @type {Package}
     * @memberof Vulnerability
     */
    'package'?: Package;
    /**
     * 
     * @type {VulnerabilityFix}
     * @memberof Vulnerability
     */
    'fix'?: VulnerabilityFix;
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'layerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'path'?: string;
}


/**
 * 
 * @export
 * @interface VulnerabilityCvss
 */
export interface VulnerabilityCvss {
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityCvss
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityCvss
     */
    'vector'?: string;
    /**
     * 
     * @type {VulnerabilityCvssMetrics}
     * @memberof VulnerabilityCvss
     */
    'metrics'?: VulnerabilityCvssMetrics;
}
/**
 * 
 * @export
 * @interface VulnerabilityCvssMetrics
 */
export interface VulnerabilityCvssMetrics {
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityCvssMetrics
     */
    'baseScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityCvssMetrics
     */
    'exploitabilityScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityCvssMetrics
     */
    'impactScore'?: number;
}
/**
 * Distro provides information about a detected Linux distribution.
 * @export
 * @interface VulnerabilityDistro
 */
export interface VulnerabilityDistro {
    /**
     * Name of the Linux distribution
     * @type {string}
     * @memberof VulnerabilityDistro
     */
    'name'?: string;
    /**
     * Version of the Linux distribution (major or major.minor version)
     * @type {string}
     * @memberof VulnerabilityDistro
     */
    'version'?: string;
    /**
     * the ID_LIKE field found within the /etc/os-release file
     * @type {Array<string>}
     * @memberof VulnerabilityDistro
     */
    'IDLike'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface VulnerabilityFindingInfo
 */
export interface VulnerabilityFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'vulnerabilityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'description'?: string;
    /**
     * 
     * @type {VulnerabilitySeverity}
     * @memberof VulnerabilityFindingInfo
     */
    'severity'?: VulnerabilitySeverity;
    /**
     * 
     * @type {Array<string>}
     * @memberof VulnerabilityFindingInfo
     */
    'links'?: Array<string> | null;
    /**
     * 
     * @type {VulnerabilityDistro}
     * @memberof VulnerabilityFindingInfo
     */
    'distro'?: VulnerabilityDistro;
    /**
     * 
     * @type {Array<VulnerabilityCvss>}
     * @memberof VulnerabilityFindingInfo
     */
    'cvss'?: Array<VulnerabilityCvss> | null;
    /**
     * 
     * @type {Package}
     * @memberof VulnerabilityFindingInfo
     */
    'package'?: Package;
    /**
     * 
     * @type {VulnerabilityFix}
     * @memberof VulnerabilityFindingInfo
     */
    'fix'?: VulnerabilityFix;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'layerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface VulnerabilityFix
 */
export interface VulnerabilityFix {
    /**
     * 
     * @type {Array<string>}
     * @memberof VulnerabilityFix
     */
    'versions'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFix
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface VulnerabilityScan
 */
export interface VulnerabilityScan {
    /**
     * 
     * @type {Array<Vulnerability>}
     * @memberof VulnerabilityScan
     */
    'vulnerabilities'?: Array<Vulnerability> | null;
}
/**
 * A summary of number of vulnerabilities found per severity.
 * @export
 * @interface VulnerabilityScanSummary
 */
export interface VulnerabilityScanSummary {
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalCriticalVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalHighVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalMediumVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalLowVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalNegligibleVulnerabilities'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VulnerabilitySeverity = {
    Critical: 'CRITICAL',
    High: 'HIGH',
    Medium: 'MEDIUM',
    Low: 'LOW',
    Negligible: 'NEGLIGIBLE'
} as const;

export type VulnerabilitySeverity = typeof VulnerabilitySeverity[keyof typeof VulnerabilitySeverity];



/**
 * VMClarityApi - axios parameter creator
 * @export
 */
export const VMClarityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('deleteAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete asset.
         * @param {string} assetID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetsAssetID: async (assetID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('deleteAssetsAssetID', 'assetID', assetID)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a finding.
         * @param {string} findingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFindingsFindingID: async (findingID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('deleteFindingsFindingID', 'findingID', findingID)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete provider.
         * @param {string} providerID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvidersProviderID: async (providerID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('deleteProvidersProviderID', 'providerID', providerID)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scan config.
         * @param {string} scanConfigID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanConfigsScanConfigID: async (scanConfigID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('deleteScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scan estimation.
         * @param {string} scanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanEstimationsScanEstimationID: async (scanEstimationID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('deleteScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scan.
         * @param {string} scanID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScansScanID: async (scanID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('deleteScansScanID', 'scanID', scanID)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get asset scan estimations according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimations: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assetScanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('getAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get asset scans according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScans: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assetScans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an asset scan.
         * @param {string} assetScanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScansAssetScanID: async (assetScanID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanID' is not null or undefined
            assertParamExists('getAssetScansAssetScanID', 'assetScanID', assetScanID)
            const localVarPath = `/assetScans/{assetScanID}`
                .replace(`{${"assetScanID"}}`, encodeURIComponent(String(assetScanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get assets
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get asset.
         * @param {string} assetID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsAssetID: async (assetID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('getAssetsAssetID', 'assetID', assetID)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindings: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a finding.
         * @param {string} findingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindingsFindingID: async (findingID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('getFindingsFindingID', 'findingID', findingID)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get this OpenAPI spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenAPISpec: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get providers
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get provider.
         * @param {string} providerID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderID: async (providerID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('getProvidersProviderID', 'providerID', providerID)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all scan configs.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigs: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scanConfigs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a scan config.
         * @param {string} scanConfigID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigsScanConfigID: async (scanConfigID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('getScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimations: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scan estimation.
         * @param {string} scanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimationsScanEstimationID: async (scanEstimationID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('getScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScans: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scheduled scan.
         * @param {string} scanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScansScanID: async (scanID: string, $select?: string, $expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('getScansScanID', 'scanID', scanID)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an asset scan estimation
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('patchAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchAssetScanEstimationsAssetScanEstimationID', 'body', body)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an asset scan
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScansAssetScanID: async (assetScanID: string, body: AssetScan, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanID' is not null or undefined
            assertParamExists('patchAssetScansAssetScanID', 'assetScanID', assetScanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchAssetScansAssetScanID', 'body', body)
            const localVarPath = `/assetScans/{assetScanID}`
                .replace(`{${"assetScanID"}}`, encodeURIComponent(String(assetScanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetsAssetID: async (assetID: string, body: Asset, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('patchAssetsAssetID', 'assetID', assetID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchAssetsAssetID', 'body', body)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFindingsFindingID: async (findingID: string, body: Finding, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('patchFindingsFindingID', 'findingID', findingID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchFindingsFindingID', 'body', body)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProvidersProviderID: async (providerID: string, body: Provider, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('patchProvidersProviderID', 'providerID', providerID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchProvidersProviderID', 'body', body)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanConfigsScanConfigID: async (scanConfigID: string, body: ScanConfig, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('patchScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchScanConfigsScanConfigID', 'body', body)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanEstimationsScanEstimationID: async (scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('patchScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchScanEstimationsScanEstimationID', 'body', body)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScansScanID: async (scanID: string, body: Scan, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('patchScansScanID', 'scanID', scanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchScansScanID', 'body', body)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an asset scan estimation for a specified asset
         * @param {AssetScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScanEstimations: async (body: AssetScanEstimation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postAssetScanEstimations', 'body', body)
            const localVarPath = `/assetScanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an asset scan for a specified asset
         * @param {AssetScan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScans: async (body: AssetScan, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postAssetScans', 'body', body)
            const localVarPath = `/assetScans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create asset
         * @param {Asset} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets: async (body: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postAssets', 'body', body)
            const localVarPath = `/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a finding
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFindings: async (body: Finding, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postFindings', 'body', body)
            const localVarPath = `/findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create provider
         * @param {Provider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProviders: async (body: Provider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postProviders', 'body', body)
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a scan config
         * @param {ScanConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanConfigs: async (body: ScanConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postScanConfigs', 'body', body)
            const localVarPath = `/scanConfigs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a multi-asset scan estimation
         * @param {ScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanEstimations: async (body: ScanEstimation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postScanEstimations', 'body', body)
            const localVarPath = `/scanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a multi-asset scheduled scan
         * @param {Scan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScans: async (body: Scan, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postScans', 'body', body)
            const localVarPath = `/scans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('putAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putAssetScanEstimationsAssetScanEstimationID', 'body', body)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an asset scan.
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScansAssetScanID: async (assetScanID: string, body: AssetScan, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanID' is not null or undefined
            assertParamExists('putAssetScansAssetScanID', 'assetScanID', assetScanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putAssetScansAssetScanID', 'body', body)
            const localVarPath = `/assetScans/{assetScanID}`
                .replace(`{${"assetScanID"}}`, encodeURIComponent(String(assetScanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetsAssetID: async (assetID: string, body: Asset, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('putAssetsAssetID', 'assetID', assetID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putAssetsAssetID', 'body', body)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFindingsFindingID: async (findingID: string, body: Finding, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('putFindingsFindingID', 'findingID', findingID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putFindingsFindingID', 'body', body)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProvidersProviderID: async (providerID: string, body: Provider, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('putProvidersProviderID', 'providerID', providerID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putProvidersProviderID', 'body', body)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanConfigsScanConfigID: async (scanConfigID: string, body: ScanConfig, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('putScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putScanConfigsScanConfigID', 'body', body)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanEstimationsScanEstimationID: async (scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('putScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putScanEstimationsScanEstimationID', 'body', body)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScansScanID: async (scanID: string, body: Scan, ifMatch?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('putScansScanID', 'scanID', scanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putScansScanID', 'body', body)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VMClarityApi - functional programming interface
 * @export
 */
export const VMClarityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VMClarityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete asset.
         * @param {string} assetID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssetsAssetID(assetID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetsAssetID(assetID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a finding.
         * @param {string} findingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFindingsFindingID(findingID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFindingsFindingID(findingID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete provider.
         * @param {string} providerID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvidersProviderID(providerID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvidersProviderID(providerID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a scan config.
         * @param {string} scanConfigID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScanConfigsScanConfigID(scanConfigID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScanConfigsScanConfigID(scanConfigID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a scan estimation.
         * @param {string} scanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScanEstimationsScanEstimationID(scanEstimationID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScanEstimationsScanEstimationID(scanEstimationID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a scan.
         * @param {string} scanID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScansScanID(scanID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScansScanID(scanID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get asset scan estimations according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get asset scans according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScans($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an asset scan.
         * @param {string} assetScanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScansAssetScanID(assetScanID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScansAssetScanID(assetScanID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get assets
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssets($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssets($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get asset.
         * @param {string} assetID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetsAssetID(assetID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetsAssetID(assetID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Findings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details for a finding.
         * @param {string} findingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFindingsFindingID(findingID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFindingsFindingID(findingID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get this OpenAPI spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenAPISpec(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenAPISpec(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get providers
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviders($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Providers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviders($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get provider.
         * @param {string} providerID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvidersProviderID(providerID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvidersProviderID(providerID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all scan configs.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanConfigs($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanConfigs($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details for a scan config.
         * @param {string} scanConfigID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanConfigsScanConfigID(scanConfigID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanConfigsScanConfigID(scanConfigID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scan estimation.
         * @param {string} scanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanEstimationsScanEstimationID(scanEstimationID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanEstimationsScanEstimationID(scanEstimationID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScans($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scheduled scan.
         * @param {string} scanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScansScanID(scanID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScansScanID(scanID, $select, $expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch an asset scan estimation
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch an asset scan
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAssetScansAssetScanID(assetScanID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAssetsAssetID(assetID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFindingsFindingID(findingID: string, body: Finding, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFindingsFindingID(findingID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProvidersProviderID(providerID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchScanConfigsScanConfigID(scanConfigID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchScansScanID(scanID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an asset scan estimation for a specified asset
         * @param {AssetScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssetScanEstimations(body: AssetScanEstimation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAssetScanEstimations(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an asset scan for a specified asset
         * @param {AssetScan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssetScans(body: AssetScan, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAssetScans(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create asset
         * @param {Asset} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssets(body: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAssets(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a finding
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFindings(body: Finding, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFindings(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create provider
         * @param {Provider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProviders(body: Provider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProviders(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a scan config
         * @param {ScanConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postScanConfigs(body: ScanConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postScanConfigs(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a multi-asset scan estimation
         * @param {ScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postScanEstimations(body: ScanEstimation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postScanEstimations(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a multi-asset scheduled scan
         * @param {Scan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postScans(body: Scan, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postScans(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an asset scan.
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAssetScansAssetScanID(assetScanID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAssetsAssetID(assetID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFindingsFindingID(findingID: string, body: Finding, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFindingsFindingID(findingID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProvidersProviderID(providerID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putScanConfigsScanConfigID(scanConfigID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putScansScanID(scanID, body, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VMClarityApi - factory interface
 * @export
 */
export const VMClarityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VMClarityApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete asset.
         * @param {string} assetID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetsAssetID(assetID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteAssetsAssetID(assetID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a finding.
         * @param {string} findingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFindingsFindingID(findingID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteFindingsFindingID(findingID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete provider.
         * @param {string} providerID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvidersProviderID(providerID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteProvidersProviderID(providerID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scan config.
         * @param {string} scanConfigID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanConfigsScanConfigID(scanConfigID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteScanConfigsScanConfigID(scanConfigID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scan estimation.
         * @param {string} scanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanEstimationsScanEstimationID(scanEstimationID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteScanEstimationsScanEstimationID(scanEstimationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scan.
         * @param {string} scanID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScansScanID(scanID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteScansScanID(scanID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get asset scan estimations according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<AssetScanEstimations> {
            return localVarFp.getAssetScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get asset scans according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<AssetScans> {
            return localVarFp.getAssetScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an asset scan.
         * @param {string} assetScanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScansAssetScanID(assetScanID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.getAssetScansAssetScanID(assetScanID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get assets
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Assets> {
            return localVarFp.getAssets($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get asset.
         * @param {string} assetID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsAssetID(assetID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Asset> {
            return localVarFp.getAssetsAssetID(assetID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Findings> {
            return localVarFp.getFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a finding.
         * @param {string} findingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindingsFindingID(findingID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Finding> {
            return localVarFp.getFindingsFindingID(findingID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get this OpenAPI spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenAPISpec(options?: any): AxiosPromise<string> {
            return localVarFp.getOpenAPISpec(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get providers
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Providers> {
            return localVarFp.getProviders($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get provider.
         * @param {string} providerID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderID(providerID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Provider> {
            return localVarFp.getProvidersProviderID(providerID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all scan configs.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigs($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<ScanConfigs> {
            return localVarFp.getScanConfigs($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a scan config.
         * @param {string} scanConfigID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigsScanConfigID(scanConfigID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.getScanConfigsScanConfigID(scanConfigID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<ScanEstimations> {
            return localVarFp.getScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scan estimation.
         * @param {string} scanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimationsScanEstimationID(scanEstimationID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.getScanEstimationsScanEstimationID(scanEstimationID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Scans> {
            return localVarFp.getScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scheduled scan.
         * @param {string} scanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScansScanID(scanID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Scan> {
            return localVarFp.getScansScanID(scanID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch an asset scan estimation
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch an asset scan
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.patchAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.patchAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFindingsFindingID(findingID: string, body: Finding, options?: any): AxiosPromise<Finding> {
            return localVarFp.patchFindingsFindingID(findingID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: any): AxiosPromise<Provider> {
            return localVarFp.patchProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.patchScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.patchScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: any): AxiosPromise<Scan> {
            return localVarFp.patchScansScanID(scanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an asset scan estimation for a specified asset
         * @param {AssetScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScanEstimations(body: AssetScanEstimation, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.postAssetScanEstimations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an asset scan for a specified asset
         * @param {AssetScan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScans(body: AssetScan, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.postAssetScans(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create asset
         * @param {Asset} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets(body: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.postAssets(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a finding
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFindings(body: Finding, options?: any): AxiosPromise<Finding> {
            return localVarFp.postFindings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create provider
         * @param {Provider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProviders(body: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.postProviders(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a scan config
         * @param {ScanConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanConfigs(body: ScanConfig, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.postScanConfigs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a multi-asset scan estimation
         * @param {ScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanEstimations(body: ScanEstimation, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.postScanEstimations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a multi-asset scheduled scan
         * @param {Scan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScans(body: Scan, options?: any): AxiosPromise<Scan> {
            return localVarFp.postScans(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an asset scan.
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.putAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.putAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFindingsFindingID(findingID: string, body: Finding, options?: any): AxiosPromise<Finding> {
            return localVarFp.putFindingsFindingID(findingID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: any): AxiosPromise<Provider> {
            return localVarFp.putProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.putScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.putScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: any): AxiosPromise<Scan> {
            return localVarFp.putScansScanID(scanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VMClarityApi - object-oriented interface
 * @export
 * @class VMClarityApi
 * @extends {BaseAPI}
 */
export class VMClarityApi extends BaseAPI {
    /**
     * 
     * @summary Delete an asset scan estimation.
     * @param {string} assetScanEstimationID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete asset.
     * @param {string} assetID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteAssetsAssetID(assetID: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteAssetsAssetID(assetID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a finding.
     * @param {string} findingID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteFindingsFindingID(findingID: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteFindingsFindingID(findingID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete provider.
     * @param {string} providerID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteProvidersProviderID(providerID: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteProvidersProviderID(providerID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scan config.
     * @param {string} scanConfigID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteScanConfigsScanConfigID(scanConfigID: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteScanConfigsScanConfigID(scanConfigID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scan estimation.
     * @param {string} scanEstimationID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteScanEstimationsScanEstimationID(scanEstimationID: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteScanEstimationsScanEstimationID(scanEstimationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scan.
     * @param {string} scanID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteScansScanID(scanID: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteScansScanID(scanID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get asset scan estimations according to the given filters
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an asset scan estimation.
     * @param {string} assetScanEstimationID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get asset scans according to the given filters
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an asset scan.
     * @param {string} assetScanID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScansAssetScanID(assetScanID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScansAssetScanID(assetScanID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get assets
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssets($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssets($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get asset.
     * @param {string} assetID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetsAssetID(assetID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetsAssetID(assetID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all findings.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a finding.
     * @param {string} findingID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getFindingsFindingID(findingID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getFindingsFindingID(findingID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get this OpenAPI spec
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getOpenAPISpec(options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getOpenAPISpec(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get providers
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getProviders($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getProviders($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get provider.
     * @param {string} providerID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getProvidersProviderID(providerID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getProvidersProviderID(providerID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all scan configs.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanConfigs($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanConfigs($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a scan config.
     * @param {string} scanConfigID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanConfigsScanConfigID(scanConfigID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanConfigsScanConfigID(scanConfigID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a given multi-asset scan estimation.
     * @param {string} scanEstimationID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanEstimationsScanEstimationID(scanEstimationID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanEstimationsScanEstimationID(scanEstimationID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a given multi-asset scheduled scan.
     * @param {string} scanID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScansScanID(scanID: string, $select?: string, $expand?: string, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScansScanID(scanID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch an asset scan estimation
     * @param {string} assetScanEstimationID 
     * @param {AssetScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch an asset scan
     * @param {string} assetScanID 
     * @param {AssetScan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update asset.
     * @param {string} assetID 
     * @param {Asset} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a finding.
     * @param {string} findingID 
     * @param {Finding} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchFindingsFindingID(findingID: string, body: Finding, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchFindingsFindingID(findingID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update provider.
     * @param {string} providerID 
     * @param {Provider} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a scan config.
     * @param {string} scanConfigID 
     * @param {ScanConfig} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a scan estimation.
     * @param {string} scanEstimationID 
     * @param {ScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a scan.
     * @param {string} scanID 
     * @param {Scan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchScansScanID(scanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an asset scan estimation for a specified asset
     * @param {AssetScanEstimation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postAssetScanEstimations(body: AssetScanEstimation, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postAssetScanEstimations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an asset scan for a specified asset
     * @param {AssetScan} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postAssetScans(body: AssetScan, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postAssetScans(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create asset
     * @param {Asset} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postAssets(body: Asset, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postAssets(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a finding
     * @param {Finding} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postFindings(body: Finding, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postFindings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create provider
     * @param {Provider} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postProviders(body: Provider, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postProviders(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a scan config
     * @param {ScanConfig} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postScanConfigs(body: ScanConfig, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postScanConfigs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a multi-asset scan estimation
     * @param {ScanEstimation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postScanEstimations(body: ScanEstimation, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postScanEstimations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a multi-asset scheduled scan
     * @param {Scan} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postScans(body: Scan, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postScans(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an asset scan estimation.
     * @param {string} assetScanEstimationID 
     * @param {AssetScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an asset scan.
     * @param {string} assetScanID 
     * @param {AssetScan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update asset.
     * @param {string} assetID 
     * @param {Asset} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a finding.
     * @param {string} findingID 
     * @param {Finding} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putFindingsFindingID(findingID: string, body: Finding, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putFindingsFindingID(findingID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update provider.
     * @param {string} providerID 
     * @param {Provider} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scan config.
     * @param {string} scanConfigID 
     * @param {ScanConfig} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scan estimation.
     * @param {string} scanEstimationID 
     * @param {ScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scan.
     * @param {string} scanID 
     * @param {Scan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: AxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putScansScanID(scanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }
}



